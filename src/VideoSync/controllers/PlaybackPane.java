/*
 * ****************************************************************
 * File: 			PlaybackPane.java
 * Date Created:  	June 26, 2013
 * Programmer:		Dale Reed
 *
 * Purpose:			To handle and control aspects related to
 * 					play back controls for moving around the data
 * 					and video files.
 *
 * Modified:		August 22, 2016
 * Programmer:		Danny Hale
 * 					Added smooth frames transitions from position
 * 					slider movement. Fixed occasional frame skip
 * 					crash. Added slow motion and moved the controls
 * 					around to accommodate the new playback options.
 * ****************************************************************
 */

package VideoSync.controllers;

import VideoSync.commands.playback.CommandFrameForward;
import VideoSync.commands.playback.CommandFrameReverse;
import VideoSync.commands.playback.CommandPlay;
import VideoSync.models.DataModelProxy;
import VideoSync.threads.ThreadSkip;

import javax.swing.*;
import javax.swing.border.BevelBorder;
import javax.swing.event.ChangeEvent;
import javax.swing.event.ChangeListener;
import java.awt.*;
import java.awt.event.MouseAdapter;
import java.awt.event.MouseEvent;
import java.awt.event.MouseListener;
import java.util.Hashtable;
import java.util.Observable;
import java.util.Observer;

public class PlaybackPane extends JPanel implements Observer, MouseListener, ChangeListener
{
    private static final long serialVersionUID = 1L;

    /**
     * Used to notify the rest of the program of any changes that may occur.
     */
    private DataModelProxy dmp;

    /**
     * Used for playing or pausing the data
     */
    private final JButton button_Play;

    /**
     * Used for fast forwarding the data
     */
    private final JButton button_FastForward;

    /**
     * Used for rewinding the data
     */
    private final JButton button_Rewind;

    /**
     * Used for jumping the frames forward one at a time
     */
    private final JButton btnFrameAdvance;

    /**
     * Used for jumping the frames backwards.
     */
    private final JButton btnJumpBack;

    /**
     * Used for indicating the data position overall.
     */
    private final JSlider slider_MoviePosition;
    private final JButton timeButton;

    /**
     * Used for choosing the data's play back speed.
     */
    private final JSlider slider_MovieSpeed;

    /**
     * Used for indicating the current time for the data.
     */
    private final JLabel lblCurrentPos;

    /**
     * Used for indicating the maximum time for the data
     */
    private final JLabel label_MaxPosition;

    /**
     * Used for skipping the data back and forth
     */
    private ThreadSkip ts;

    /**
     * Used to keep track of whether a video was playing or not before the movie slider was grabbed.
     */
    private Boolean playingBeforeSlider;

    /**
     * Construct the Playback Pane to be displayed in the Data Window.
     * <p>
     * Note: This sets up all the user interface elements to be displayed in the Event Detection Pane.
     * Most of this code has been generated by Window Builder for Eclipse
     */
    public PlaybackPane()
    {
        setBorder(new BevelBorder(BevelBorder.LOWERED, null, null, null, null));
        setSize(new Dimension(435, 128));
        setLayout(new BorderLayout(0, 0));

        JLabel lblPlaybackControls = new JLabel("Playback Controls");
        add(lblPlaybackControls, BorderLayout.NORTH);
        lblPlaybackControls.setHorizontalAlignment(SwingConstants.CENTER);

        JPanel panel_2 = new JPanel();
        add(panel_2, BorderLayout.CENTER);
        panel_2.setLayout(null);

        JLabel lblMoviePosition = new JLabel("Movie Position");
        lblMoviePosition.setFont(new Font("Lucida Grande", Font.PLAIN, 10));
        lblMoviePosition.setBounds(8, 5, 77, 15);
        panel_2.add(lblMoviePosition);

        slider_MoviePosition = new JSlider();
        slider_MoviePosition.setEnabled(false);
        slider_MoviePosition.addMouseListener(this);
        slider_MoviePosition.addChangeListener(this);    //Allows smooth frame transitions
        //slider_MoviePosition.ad
        slider_MoviePosition.setValue(0);
        slider_MoviePosition.setMinimum(1);
        slider_MoviePosition.setMaximum(100);
        slider_MoviePosition.setBounds(80, 0, 340, 30);
        panel_2.add(slider_MoviePosition);

        slider_MovieSpeed = new JSlider();
        slider_MovieSpeed.setMajorTickSpacing(1);
        slider_MovieSpeed.setValue(1);
        slider_MovieSpeed.setMaximum(8);
        slider_MovieSpeed.setMinimum(-2);

        Hashtable<Integer, JLabel> labelTable = new Hashtable<>();
        labelTable.put(-2, new JLabel(".10"));
        labelTable.put(-1, new JLabel(".30"));
        labelTable.put(0, new JLabel(".50"));
        labelTable.put(1, new JLabel("1.0"));
        labelTable.put(2, new JLabel("2.0"));
        labelTable.put(3, new JLabel("3.0"));
        labelTable.put(4, new JLabel("4.0"));
        labelTable.put(5, new JLabel("5.0"));
        labelTable.put(6, new JLabel("6.0"));
        labelTable.put(7, new JLabel("7.0"));
        labelTable.put(8, new JLabel("8.0"));
        slider_MovieSpeed.setLabelTable(labelTable);

        JLabel lblMovieSpeed = new JLabel("Movie Speed");
        lblMovieSpeed.setFont(new Font("Lucida Grande", Font.PLAIN, 10));
        lblMovieSpeed.setBounds(8, 30, 77, 16);
        panel_2.add(lblMovieSpeed);

        slider_MovieSpeed.setPaintTicks(true);
        slider_MovieSpeed.setPaintLabels(true);
        slider_MovieSpeed.setSnapToTicks(true);
        slider_MovieSpeed.setEnabled(false);
        slider_MovieSpeed.setBounds(80, 34, 340, 36);
        slider_MovieSpeed.addChangeListener(this);
        panel_2.add(slider_MovieSpeed);


        lblCurrentPos = new JLabel("");
        lblCurrentPos.setBounds(8, 72, 114, 16);
        panel_2.add(lblCurrentPos);

        label_MaxPosition = new JLabel("");
        label_MaxPosition.setBounds(8, 88, 114, 16);
        panel_2.add(label_MaxPosition);

        button_Rewind = new JButton("<<");
        button_Rewind.setToolTipText("Rewind");
        button_Rewind.setEnabled(false);
        button_Rewind.setBounds(124, 75, 54, 28);
        button_Rewind.addMouseListener(this);
        panel_2.add(button_Rewind);

        btnJumpBack = new JButton("Jump Back");
        btnJumpBack.setToolTipText("Jump Back");
        btnJumpBack.setEnabled(false);
        btnJumpBack.setBounds(178, 75, 54, 28);
        panel_2.add(btnJumpBack);

        button_Play = new JButton("Play");
        button_Play.setEnabled(false);
        button_Play.setBounds(232, 75, 80, 28);
        panel_2.add(button_Play);

        btnFrameAdvance = new JButton(">");
        btnFrameAdvance.setToolTipText("Frame Advance");
        btnFrameAdvance.setEnabled(false);
        btnFrameAdvance.setBounds(306, 75, 54, 28);
        panel_2.add(btnFrameAdvance);

        button_FastForward = new JButton(">>");
        button_FastForward.setToolTipText("Fast Forward");
        button_FastForward.setEnabled(false);
        button_FastForward.setBounds(360, 75, 54, 28);
        button_FastForward.addMouseListener(this);
        panel_2.add(button_FastForward);

        timeButton = new JButton("Timestamp");
        timeButton.setFont(new Font("Dialog", Font.BOLD, 10));
        timeButton.setMargin(new Insets(0, 0, 0, 0));
        timeButton.setEnabled(false);
        timeButton.setBounds(5, 52, 74, 21);


        lblCurrentPos.setToolTipText("Click this label to JUMP to a timestamp");

        lblCurrentPos.addMouseListener(new MouseAdapter()
        {
            @Override
            public void mouseClicked(MouseEvent e)
            {
                UIManager.put("OptionPane.cancelButtonText", "CANCEL");
                UIManager.put("OptionPane.okButtonText", "ENTER");
                String str = JOptionPane.showInputDialog(PlaybackPane.this, "TimeStamp [mm:ss.millisec]: ", null);

                if(str != null)
                {
                    String[] data = str.split("[:.]");

                    // milliseconds broken into minutes, seconds, ms
                    int minutes = Integer.parseInt(data[0]);
                    int seconds = Integer.parseInt(data[1]);
                    int milliseconds = Integer.parseInt(data[2]);

                    int time = milliseconds + (1000 * seconds) + (1000 * 60 * minutes);

                    System.out.println("Timestamp Jump to : " + time);
                    slider_MoviePosition.setValue(time);
                    System.out.println(slider_MoviePosition.getValue());

                    int x_time = slider_MoviePosition.getValue();
                    dmp.setSliderPosition(x_time);
                }
            }
        });


    }

    /**
     * Enables all of the items that can be enabled.
     *
     * @param enable Boolean specifying whether to enable items or not.
     */
    public void enableAllItems(boolean enable)
    {
        slider_MoviePosition.setEnabled(enable);
        slider_MovieSpeed.setEnabled(enable);
        button_Rewind.setEnabled(enable);
        button_FastForward.setEnabled(enable);
        button_Play.setEnabled(enable);
        btnFrameAdvance.setEnabled(enable);
        btnJumpBack.setEnabled(enable);
        timeButton.setEnabled(enable);
    }

    /**
     * Update the slider's position with the maximum value.
     *
     * @param max Maximum value
     */
    public void updateSliderMax(int max)
    {
        slider_MoviePosition.setMaximum(max);
    }

    /**
     * Update the labels based on information from the data model
     */
    public void updateLabels()
    {
        // Update the current time label from the data model's current position
        lblCurrentPos.setText(convertToTimeFormat(dmp.getCurrentPosition()));

        // Update the current time label from the data model's maximum time
        label_MaxPosition.setText(convertToTimeFormat(dmp.getSliderMax()));
    }


    /**
     * Convert the millisecond time value to HH:MM:SS.millis that is more human readable
     *
     * @param msTime Time in milliseconds
     * @return String representing time in HH:MM:SS.millis format
     */
    private String convertToTimeFormat(long msTime)
    {
        // Get the number of millis in the time
        int millis = (int) (msTime - ((msTime / 1000) * 1000));

        // Get the number of seconds in the time
        int seconds = (int) (msTime / 1000);

        // As long as seconds is greater than 59, subtract 60 from it
        while(seconds > 59)
        {
            seconds -= 60;
        }

        // Get the number of minutes from the millisecond time
        int minutes = (int) (msTime / 1000) / 60;

        // Get the total number of hours from the value of minutes
        int hours = minutes / 60;

        // Return the formatted string
        return String.format("%02d:%02d:%02d.%03d", hours, minutes, seconds, millis);
    }

    /**
     * Sets the action command for the Play Action
     *
     * @param commandPlay Command object for the Play action
     */
    public void setPlayActionCommand(CommandPlay commandPlay)
    {
        button_Play.setAction(commandPlay);
        button_Play.setText("Play");
        button_Play.setEnabled(false);
    }

    /**
     * Sets the action command for the Frame Forwards Action
     *
     * @param commandForward Command object for the Frame Forwards Action
     */
    public void setFrameForwardActionCommand(CommandFrameForward commandForward)
    {
        btnFrameAdvance.setAction(commandForward);
        btnFrameAdvance.setText(">");
        btnFrameAdvance.setToolTipText("Frame Advance");
        btnFrameAdvance.setEnabled(false);
    }

    /**
     * Sets the action command for the Frame Backwards Action
     *
     * @param commandReverse Command object for the Frame Backwards action
     */
    public void setFrameBackwardActionCommand(CommandFrameReverse commandReverse)
    {
        btnJumpBack.setAction(commandReverse);
        btnJumpBack.setText("<");
        btnJumpBack.setToolTipText("Frame Back");
        btnJumpBack.setEnabled(false);
    }

    /**
     * Invoked when the Data Model sends out a notification that an event changed that requires the
     * observers to pay attention to the data coming in
     */
    public void update(Observable o, Object arg)
    {
        // Check to see if arg is an instance of the DataModelProxy
        if(arg instanceof DataModelProxy)
        {
            // If dmp is null, then we assign arg to dmp
            if(dmp == null)
            {
                dmp = (DataModelProxy) arg;
            }

            // Check to see if we loaded data successfully into the DataModel
            // If there is data loaded in the data model, then we can enable all the UI elements.
            // Otherwise we disable everything until data is loaded.
            if(dmp.dataLoaded())
            {
                enableAllItems(true);

                // Update the slider's max value
                updateSliderMax((int) dmp.getSliderMax());

                // Update all of the Labels
                updateLabels();

                // Set the current position of the slider's position to the value in the data model
                slider_MoviePosition.setValue((int) dmp.getCurrentPosition());
                //slider_MoviePosition.setValue(x);

                // Set the current position of the playback speed slider position to the value in the data model
                slider_MovieSpeed.setValue(dmp.getPlaybackRateSliderPosition());

                // If the data model is playing, then set the play button text to "Pause"
                // Otherwise set it to "Play"
                if(dmp.isPlaying())
                {
                    button_Play.setText("Pause");
                }
                else
                {
                    button_Play.setText("Play");
                }


            }
            else
            {
                // Disable all the items
                enableAllItems(false);
            }
        }
    }

    /**
     * Invoked when any UI elements with a ChangeListener event fires
     */
    public void stateChanged(ChangeEvent e)
    {
        JSlider slider = (JSlider) e.getSource();
        // If the source of the change event is the movie speed slider,
        // we then update the playback rate in the data model and notify
        // all of the model's listeners
        if(slider == slider_MovieSpeed)
        {
            float rate;
            // Set the playback rate to the value of the slider
            int x = ((JSlider) e.getSource()).getValue();
            System.out.println("Slider playback rate: " + x);
            switch(x)
            {
                case -2:
                    rate = 0.10f;
                    break;
                case -1:
                    rate = 0.30f;
                    break;
                case 0:
                    rate = 0.50f;
                    break;
                default:
                    rate = (float) ((JSlider) e.getSource()).getValue();
            }
            System.out.println("Current Playback Slider Position: " + x);
            System.out.println("Current Playback Rate: " + rate);
            dmp.setPlaybackRateSliderPosition(x);
            dmp.setPlaybackRate(rate);
        }
        else if(slider == slider_MoviePosition && slider.getValueIsAdjusting())
        {
            dmp.setSliderPosition(slider.getValue());

        }


    }

    /**
     * Invoked when any UI elements with a MouseListener event fires
     */
    public void mousePressed(MouseEvent e)
    {
        // If the source of the event is the rewind button, then start
        // skipping the video backwards.
        if(e.getSource() == button_Rewind)
        {
            // If the ThreadSkip object is null, stop the old
            // thread and create a new thread skip object.
            if(ts != null)
            {
                ts.stopThread();
            }
            // Create the thread skip with the dmp and direction values.
            // Direction parameter of -1 means backwards
            ts = new ThreadSkip(this.dmp, -1);
            // Start skipping the data
            ts.start();
        }
        // If the source of the event is the fast forward button, then start
        // skipping the video backwards.
        else if(e.getSource() == button_FastForward)
        {
            // If the ThreadSkip object is null, stop the old
            // thread and create a new thread skip object.
            if(ts != null)
            {
                ts.stopThread();

            }
            // Create the thread skip with the dmp and direction values.
            // Direction parameter of 1 means forwards
            ts = new ThreadSkip(this.dmp, 1);
            // Start skipping the data
            ts.start();
        }
        else if(e.getSource() == slider_MoviePosition)
        {
            //If the slider is moving, we need to pause the video so that it doesn't stutter and potentially go to the wrong spot while scrubbing
            playingBeforeSlider = dmp.isPlaying();
            if(playingBeforeSlider)
            {
                dmp.setPlaying(false);
            }
        }
    }

    public void mouseReleased(MouseEvent e)
    {
        // If the source of our event is either the rewind or fast forward buttons,
        // we can stop the thread skip.
        if(e.getSource() == button_Rewind || e.getSource() == button_FastForward)
        {
            // Stop skipping the data
            ts.stopThread();
        }
        // Otherwise we have a slider event and can tell the data model to update
        // all observers with the value of the slider
        else
        {
            // Ensure that the data model proxy is not null and is not playing
            if(dmp != null && !dmp.isPlaying())
            {
                // Ensure that the source is our movie position slider
                if(e.getSource() == slider_MoviePosition)
                {
                    // Create a temporary object for our source slider
                    JSlider slider = (JSlider) e.getSource();

                    // Set the position of the slider to the one that we pass
                    dmp.setSliderPosition(slider.getValue());

                    //If the video was playing before the slider was grabbed, continue playback
                    if(playingBeforeSlider)
                    {
                        dmp.setPlaying(true);
                        playingBeforeSlider = false;
                    }
                }
            }
        }
    }


    /**
     * The following functions pertain to the various implementations that are currently not being used by the class.
     */
    public void mouseClicked(MouseEvent e)
    {
    }

    public void mouseEntered(MouseEvent e)
    {
    }

    public void mouseExited(MouseEvent e)
    {
    }
}
